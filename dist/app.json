[{"name":"app.R","content":"library(shiny)\r\nlibrary(bslib)\r\nlibrary(jsonlite)\r\n\r\nui <- page_sidebar(\r\n  title = \"Offline Data Collection\",\r\n  sidebar = sidebar(\r\n    h4(\"Data Collection Form\"),\r\n    textInput(\"participant_id\", \"Participant ID\", placeholder = \"Enter ID\"),\r\n    selectInput(\"location\", \"Location\",\r\n                choices = c(\"\", \"Site A\", \"Site B\", \"Site C\", \"Other\"), selected = \"\"\r\n    ),\r\n    numericInput(\"measurement\", \"Measurement Value\", value = NULL, min = 0),\r\n    textAreaInput(\"notes\", \"Notes\", placeholder = \"Optional notes\", rows = 3),\r\n    br(),\r\n    actionButton(\"save_record\", \"Save Record\", class = \"btn-primary\", width = \"100%\"),\r\n    hr(),\r\n    h5(\"Connection Status\"),\r\n    div(\r\n      id = \"connection_status\",\r\n      style = \"padding: 10px; border-radius: 5px; margin: 10px 0;\",\r\n      \"ðŸŸ¡ Detecting...\"\r\n    ),\r\n    br(),\r\n    actionButton(\"sync_data\", \"Sync to Server\", class = \"btn-success\", width = \"100%\"),\r\n    actionButton(\"export_data\", \"Export as JSON\", class = \"btn-info\", width = \"100%\"),\r\n    actionButton(\"clear_local\", \"Clear Local Data\", class = \"btn-warning\", width = \"100%\")\r\n  ),\r\n  card(\r\n    card_header(\"Stored Records\"),\r\n    div(id = \"records_display\"),\r\n    hr(),\r\n    h5(\"Local Storage Summary\"),\r\n    verbatimTextOutput(\"storage_summary\")\r\n  ),\r\n  # --- JS for offline/local-first behavior (works in Shinylive) ---\r\n  tags$script(HTML(\"\r\n    // ---------- CONFIG ----------\r\n    const DATA_KEY = 'shinylive_offline_data_collection';\r\n    const SYNC_URL = '/api/collect'; // <- replace with your endpoint when you have one\r\n\r\n    // ---------- STORAGE ----------\r\n    function initStorage() {\r\n      if (!localStorage.getItem(DATA_KEY)) {\r\n        localStorage.setItem(DATA_KEY, JSON.stringify([]));\r\n      }\r\n    }\r\n    function getAllRecords() {\r\n      return JSON.parse(localStorage.getItem(DATA_KEY) || '[]');\r\n    }\r\n    function saveRecord(record) {\r\n      let data = getAllRecords();\r\n      record.id = Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9);\r\n      record.timestamp = new Date().toISOString();\r\n      record.synced = false;\r\n      data.push(record);\r\n      localStorage.setItem(DATA_KEY, JSON.stringify(data));\r\n      updateDisplay(); updateShinyStorageSummary();\r\n      return record.id;\r\n    }\r\n    function markSynced(ids) {\r\n      let data = getAllRecords();\r\n      data.forEach(r => { if (ids.includes(r.id)) { r.synced = true; r.sync_timestamp = new Date().toISOString(); }});\r\n      localStorage.setItem(DATA_KEY, JSON.stringify(data));\r\n      updateDisplay(); updateShinyStorageSummary();\r\n    }\r\n    function clearLocalData() {\r\n      localStorage.removeItem(DATA_KEY);\r\n      initStorage(); updateDisplay(); updateShinyStorageSummary();\r\n    }\r\n\r\n    // ---------- EXPORT ----------\r\n    function exportData() {\r\n      const records = getAllRecords();\r\n      if (records.length === 0) { alert('No data to export!'); return; }\r\n      const payload = { export_timestamp: new Date().toISOString(), total_records: records.length, records };\r\n      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});\r\n      const url = URL.createObjectURL(blob);\r\n      const a = document.createElement('a');\r\n      a.href = url;\r\n      a.download = 'offline_data_' + new Date().toISOString().split('T')[0] + '.json';\r\n      document.body.appendChild(a); a.click(); document.body.removeChild(a);\r\n      URL.revokeObjectURL(url);\r\n      alert('Data exported successfully!');\r\n    }\r\n\r\n    // ---------- UI ----------\r\n    function updateShinyStorageSummary() {\r\n      const recs = getAllRecords(); const total = recs.length;\r\n      const synced = recs.filter(r => r.synced).length; const pending = total - synced;\r\n      if (typeof Shiny !== 'undefined' && Shiny.setInputValue) {\r\n        Shiny.setInputValue('storage_counts', { total, synced, pending, timestamp: Date.now() });\r\n      }\r\n    }\r\n    function updateDisplay() {\r\n      const records = getAllRecords().sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp));\r\n      const display = document.getElementById('records_display');\r\n      if (!display) return;\r\n      if (records.length === 0) { display.innerHTML = '<p class=\\\"text-muted\\\">No records stored locally.<\/p>'; return; }\r\n      let html = '<div class=\\\"row\\\">';\r\n      records.slice(0, 10).forEach(record => {\r\n        const badge = record.synced ? '<span class=\\\"badge bg-success\\\">Synced<\/span>'\r\n                                    : '<span class=\\\"badge bg-warning text-dark\\\">Pending<\/span>';\r\n        html += `\r\n          <div class=\\\"col-md-6 mb-3\\\">\r\n            <div class=\\\"card border-0 shadow-sm\\\">\r\n              <div class=\\\"card-body\\\">\r\n                <h6 class=\\\"card-title d-flex justify-content-between align-items-center\\\">\r\n                  ID: ${record.participant_id} ${badge}\r\n                <\/h6>\r\n                <p class=\\\"card-text small\\\">\r\n                  <strong>Location:<\/strong> ${record.location}<br>\r\n                  <strong>Measurement:<\/strong> ${record.measurement}<br>\r\n                  <strong>Time:<\/strong> ${new Date(record.timestamp).toLocaleString()}\r\n                <\/p>\r\n                ${record.notes ? `<p class=\\\"card-text small\\\"><strong>Notes:<\/strong> ${record.notes}<\/p>` : ''}\r\n              <\/div>\r\n            <\/div>\r\n          <\/div>`;\r\n      });\r\n      if (records.length > 10) {\r\n        html += `<div class=\\\"col-12\\\"><p class=\\\"text-muted text-center\\\">Showing latest 10 of ${records.length} records<\/p><\/div>`;\r\n      }\r\n      html += '<\/div>';\r\n      display.innerHTML = html;\r\n    }\r\n\r\n    // ---------- ONLINE / OFFLINE UX ----------\r\n    function setStatus(online) {\r\n      const el = document.getElementById('connection_status'); if (!el) return;\r\n      if (online) { el.innerHTML = 'ðŸŸ¢ Online (data persists in browser)'; el.style.backgroundColor = '#d4edda'; el.style.color = '#155724'; }\r\n      else        { el.innerHTML = 'ðŸ”´ Offline (safe to collect; will sync later)'; el.style.backgroundColor = '#f8d7da'; el.style.color = '#721c24'; }\r\n    }\r\n\r\n    // ---------- SYNC ----------\r\n    async function syncToServerReal() {\r\n      const unsynced = getAllRecords().filter(r => !r.synced);\r\n      if (unsynced.length === 0) { alert('No records to sync!'); return; }\r\n      const btn = document.querySelector('#sync_data'); const orig = btn.innerHTML;\r\n      try {\r\n        btn.innerHTML = 'Syncing...'; btn.disabled = true;\r\n        // NOTE: replace SYNC_URL with a real endpoint. Example payload below:\r\n        const resp = await fetch(SYNC_URL, {\r\n          method: 'POST',\r\n          headers: { 'Content-Type': 'application/json' },\r\n          body: JSON.stringify({ device_timestamp: new Date().toISOString(), records: unsynced })\r\n        });\r\n        if (!resp.ok) throw new Error('HTTP ' + resp.status);\r\n        // Expect server to return the list of accepted record IDs, or echo back records\r\n        const result = await resp.json();\r\n        const ids = result.ids || unsynced.map(r => r.id); // fallback: mark all\r\n        markSynced(ids);\r\n        alert(`Successfully synced ${ids.length} records!`);\r\n      } catch (e) {\r\n        alert('Sync failed: ' + e.message + '\\\\nData remains safely stored locally.');\r\n      } finally {\r\n        btn.innerHTML = orig; btn.disabled = false;\r\n      }\r\n    }\r\n\r\n    // Default: if no server yet, simulate success so field teams can test UX\r\n    async function syncToServerSim() {\r\n      const unsynced = getAllRecords().filter(r => !r.synced);\r\n      if (unsynced.length === 0) { alert('No records to sync!'); return; }\r\n      const btn = document.querySelector('#sync_data'); const orig = btn.innerHTML;\r\n      try {\r\n        btn.innerHTML = 'Syncing...'; btn.disabled = true;\r\n        await new Promise(r => setTimeout(r, 1200));\r\n        const ids = unsynced.map(r => r.id);\r\n        markSynced(ids);\r\n        alert(`Successfully synced ${ids.length} records! (Simulated)`);\r\n      } finally {\r\n        btn.innerHTML = orig; btn.disabled = false;\r\n      }\r\n    }\r\n\r\n    // Use real sync if SYNC_URL set; otherwise simulate\r\n    function syncToServer() {\r\n      if (SYNC_URL && SYNC_URL !== '/api/collect') return syncToServerReal();\r\n      return syncToServerSim();\r\n    }\r\n\r\n    // ---------- INIT + EVENTS ----------\r\n    function initializeApp() {\r\n      initStorage(); updateDisplay(); updateShinyStorageSummary();\r\n      setStatus(navigator.onLine);\r\n      window.addEventListener('online',  () => setStatus(true));\r\n      window.addEventListener('offline', () => setStatus(false));\r\n      // Optional: Background Sync (if SW registers 'sync'); otherwise manual button\r\n      if ('serviceWorker' in navigator) {\r\n        navigator.serviceWorker.ready.then(reg => {\r\n          if ('sync' in reg) {\r\n            // Example: queue name 'offline-sync'; you could trigger reg.sync.register('offline-sync')\r\n          }\r\n        });\r\n      }\r\n    }\r\n    $(document).ready(() => setTimeout(initializeApp, 300));\r\n\r\n    $(document).on('click', '#save_record', function() {\r\n      const id = document.getElementById('participant_id').value.trim();\r\n      const loc = document.getElementById('location').value;\r\n      const meas = document.getElementById('measurement').value;\r\n      const notes = document.getElementById('notes').value;\r\n      if (!id || !loc || !meas) { alert('Please fill in all required fields (ID, Location, Measurement)'); return; }\r\n      saveRecord({ participant_id: id, location: loc, measurement: parseFloat(meas), notes });\r\n      document.getElementById('participant_id').value = '';\r\n      document.getElementById('location').value = '';\r\n      document.getElementById('measurement').value = '';\r\n      document.getElementById('notes').value = '';\r\n      alert('Record saved locally! Total records: ' + getAllRecords().length);\r\n    });\r\n    $(document).on('click', '#sync_data',   () => syncToServer());\r\n    $(document).on('click', '#export_data', () => exportData());\r\n    $(document).on('click', '#clear_local', () => {\r\n      if (confirm('Are you sure you want to clear all local data? This cannot be undone!')) {\r\n        clearLocalData(); alert('Local data cleared!');\r\n      }\r\n    });\r\n  \"))\r\n)\r\n\r\nserver <- function(input, output, session) {\r\n  storage_data <- reactiveVal(list(total = 0, synced = 0, pending = 0))\r\n  observeEvent(input$storage_counts, {\r\n    if (!is.null(input$storage_counts)) {\r\n      storage_data(list(\r\n        total   = input$storage_counts$total   %||% 0,\r\n        synced  = input$storage_counts$synced  %||% 0,\r\n        pending = input$storage_counts$pending %||% 0\r\n      ))\r\n    }\r\n  }, ignoreInit = FALSE)\r\n  output$storage_summary <- renderText({\r\n    d <- storage_data()\r\n    paste0(\r\n      'Total Records: ', d$total, '\\n',\r\n      'Synced: ', d$synced, '\\n',\r\n      'Pending Sync: ', d$pending, '\\n',\r\n      'Storage: Browser Local Storage\\n',\r\n      'Platform: Shinylive (webR)\\n',\r\n      'Last Updated: ', format(Sys.time(), '%H:%M:%S')\r\n    )\r\n  })\r\n  `%||%` <- function(x, y) if (is.null(x)) y else x\r\n}\r\n\r\nshinyApp(ui, server)","type":"text"},{"name":"Test Low Bandwidth.Rproj","content":"Version: 1.0\r\n\r\nRestoreWorkspace: Default\r\nSaveWorkspace: Default\r\nAlwaysSaveHistory: Default\r\n\r\nEnableCodeIndexing: Yes\r\nUseSpacesForTab: Yes\r\nNumSpacesForTab: 2\r\nEncoding: UTF-8\r\n\r\nRnwWeave: Sweave\r\nLaTeX: pdfLaTeX\r\n","type":"text"}]
